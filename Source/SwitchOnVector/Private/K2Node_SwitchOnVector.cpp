// Fill out your copyright notice in the Description page of Project Settings.


#include "K2Node_SwitchOnVector.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "EdGraph/EdGraphNode.h"

#include "Internationalization/Internationalization.h"

#include "UObject/Class.h"

#include "UObject/UnrealType.h"



UK2Node_SwitchOnVector::UK2Node_SwitchOnVector()
    : Super()
{
	FunctionName = TEXT("IsVectorNotNearlyEqual");
	FunctionClass = UK2Node_SwitchOnVector::StaticClass();
}

void UK2Node_SwitchOnVector::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}

FText UK2Node_SwitchOnVector::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    return NSLOCTEXT("K2Node", "Switch_Vector", "Switch on Vector");

}

bool UK2Node_SwitchOnVector::IsVectorNotNearlyEqual(FVector& A, FVector& B)
{
    return !FVector::PointsAreNear(A, B, 0.1);
}



void UK2Node_SwitchOnVector::CreateSelectionPin()
{

    const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
    UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Struct, TBaseStructure<FVector>::Get(), TEXT("Selection"));
    K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);

}


FName UK2Node_SwitchOnVector::GetPinNameGivenIndex(int32 Index) const
{
    check(Index);
    return PinNames[Index];
}

FEdGraphPinType UK2Node_SwitchOnVector::GetPinType() const
{
	FEdGraphPinType PinType;
	PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
	PinType.PinSubCategoryObject = TBaseStructure<FVector>::Get();
	return PinType;
}

void UK2Node_SwitchOnVector::CreateCasePins()
{
    while (PinValues.Num() > PinNames.Num())
    {
        const FName PinName = GetUniquePinName();
        PinNames.Add(PinName);
    }

    if (PinNames.Num() > PinValues.Num())
    {
        PinNames.SetNum(PinValues.Num());
    }

    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {

        PinNames[Index] = PinNames[Index];

        // UEdGraphPin* Test = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, TBaseStructure<FVector>::Get(), PinNames[Index]);
         UEdGraphPin* Pin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinNames[Index]);
         Pin->bAllowFriendlyName = false;
         Pin->PinFriendlyName = FText::FromString(PinValues[Index].ToString());
         Pin->SourceIndex = Index;

    }


}



FName UK2Node_SwitchOnVector::GetUniquePinName()
{
    FName NewPinName;
    int32 Index = 0;
    while (true)
    {
        NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
        if (!FindPin(NewPinName))
        {
            break;
        }
    }
    return NewPinName;
}

FString UK2Node_SwitchOnVector::GetExportTextForPin(const UEdGraphPin* InPin) const
{
	
	return FString::Printf(TEXT("(X=%3.3f,Y=%3.3f,Z=%3.3f)"), PinValues[InPin->SourceIndex].X, PinValues[InPin->SourceIndex].Y, PinValues[InPin->SourceIndex].Z);
}



void UK2Node_SwitchOnVector::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
    bool bIsDirty = false;
    FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;
    if (PropertyName == TEXT("PinValues"))
    {
        bIsDirty = true;
    }

    if (PropertyName == TEXT("X"))
    {
		bIsDirty = true;
	}
    
    if (PropertyName == TEXT("Y"))
    {
        bIsDirty = true;    
    }

    if (PropertyName == TEXT("Z"))
    {
		bIsDirty = true;
	}




    if (bIsDirty)
    {
         ReconstructNode();
    }
    Super::PostEditChangeProperty(PropertyChangedEvent);
    GetGraph()->NotifyNodeChanged(this);

}


