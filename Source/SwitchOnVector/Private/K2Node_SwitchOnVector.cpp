// Fill out your copyright notice in the Description page of Project Settings.


#include "K2Node_SwitchOnVector.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraph/EdGraph.h"
#include "EdGraphSchema_K2.h"




UK2Node_SwitchOnVector::UK2Node_SwitchOnVector()
{
	//bHasDefaultPin = false;
    
	FunctionClass = UK2Node_SwitchOnVector::StaticClass();
	FunctionName = TEXT("IsVectorNotNearlyEqual");

   
}

void UK2Node_SwitchOnVector::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}

FText UK2Node_SwitchOnVector::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    return NSLOCTEXT("K2Node", "Switch_Vector", "Switch on Vector");

}

bool UK2Node_SwitchOnVector::IsVectorNotNearlyEqual(FVector& A, FVector& B)
{
    UE_LOG(LogTemp, Warning, TEXT("IsVectorNearlyEqual, %s, %s, %s"), *A.ToString(), *B.ToString(), FVector::PointsAreNear(A, B, 0.1) ? TEXT("true") : TEXT("false"));
    return !FVector::PointsAreNear(A, B, 0.1);
}



void UK2Node_SwitchOnVector::CreateSelectionPin()
{

    const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
    UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Struct, TBaseStructure<FVector>::Get(), TEXT("Selection"));
    K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);

}


FName UK2Node_SwitchOnVector::GetPinNameGivenIndex(int32 Index) const
{
    UE_LOG(LogTemp, Warning, TEXT("GetPinNameGivenIndex, %d"), Index);
    
    check(Index);
    return PinNames[Index];
}


FEdGraphPinType UK2Node_SwitchOnVector::GetPinType() const
{
    return FEdGraphPinType(UEdGraphSchema_K2::PC_Struct, NAME_None, TBaseStructure<FVector>::Get(), EPinContainerType::None, false, FEdGraphTerminalType());
}


void UK2Node_SwitchOnVector::CreateCasePins()
{
    while (PinValues.Num() > PinNames.Num())
    {
        const FName PinName = GetUniquePinName();
        PinNames.Add(PinName);
    }

    if (PinNames.Num() > PinValues.Num())
    {
        PinNames.SetNum(PinValues.Num());
    }

    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {

         PinNames[Index] = FName(PinValues[Index].ToString());


        CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinNames[Index]);
    }

    //CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, TEXT("Default"));
}

FName UK2Node_SwitchOnVector::GetUniquePinName()
{
    FName NewPinName;
    int32 Index = 0;
    while (true)
    {
        NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
        if (!FindPin(NewPinName))
        {
            break;
        }
    }
    return NewPinName;
}

FEdGraphPinType UK2Node_SwitchOnVector::GetInnerCaseType() const
{
    return FEdGraphPinType(UEdGraphSchema_K2::PC_Struct, NAME_None, TBaseStructure<FVector>::Get(), EPinContainerType::None, false, FEdGraphTerminalType());
}

void UK2Node_SwitchOnVector::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
    bool bIsDirty = false;
    FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;
    if (PropertyName == TEXT("PinValues"))
    {
        bIsDirty = true;
    }

    if (PropertyName == TEXT("X"))
    {
		bIsDirty = true;
	}
    
    if (PropertyName == TEXT("Y"))
    {
        bIsDirty = true;    
    }

    if (PropertyName == TEXT("Z"))
    {
		bIsDirty = true;
	}




    if (bIsDirty)
    {
         ReconstructNode();
    }
    Super::PostEditChangeProperty(PropertyChangedEvent);
    GetGraph()->NotifyNodeChanged(this);

    UE_LOG(LogTemp, Warning, TEXT("PostEditChangeProperty: %s"), *PropertyName.ToString());
}
