// Copyright Amir Ben-Kiki 2025

// Fill out your copyright notice in the Description page of Project Settings.


#include "K2Node_SwitchOnIntArray.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "EdGraph/EdGraphNode.h"
#include "KismetCompiler.h"
#include "EdGraphUtilities.h"
#include "Internationalization/Internationalization.h"
#include "UObject/Class.h"
#include "UObject/UnrealType.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "K2Node_VariableGet.h"
#include "Logging/LogMacros.h"
#include "Engine/Engine.h"

// Simple log category
DEFINE_LOG_CATEGORY_STATIC(LogSwitchOnIntArray, Log, All);

bool UK2Node_SwitchOnIntArray::AreIntsNotEqual(int32 A, int32 B)
{
    UE_LOG(LogSwitchOnIntArray, Warning, TEXT("AreIntsNotEqual CALLED - A=%d, B=%d"), A, B);

    // Return TRUE to SKIP this path (when values don't match)
    // Return FALSE to EXECUTE this path (when values match)
    bool Result = (A != B);

    UE_LOG(LogSwitchOnIntArray, Warning, TEXT("  - Result=%s (%s - path will be %s)"),
        Result ? TEXT("true") : TEXT("false"),
        Result ? TEXT("not equal") : TEXT("equal"),
        Result ? TEXT("SKIPPED") : TEXT("EXECUTED"));

    return Result;
}

UK2Node_SwitchOnIntArray::UK2Node_SwitchOnIntArray()
{
    //Set the default function name and class, this is the function that will be called when the switch is executed, if it returns true the output pin will be executed
    FunctionName = TEXT("AreIntsNotEqual");
    FunctionClass = UK2Node_SwitchOnIntArray::StaticClass();
    UE_LOG(LogSwitchOnIntArray, Log, TEXT("SwitchOnIntArray created"));
}

void UK2Node_SwitchOnIntArray::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}

FText UK2Node_SwitchOnIntArray::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    return INVTEXT("Switch on Int Array");
}

inline FText UK2Node_SwitchOnIntArray::GetTooltipText() const
{
    return INVTEXT("Switch statement using an array of ints,\nunlike the standard switch that only works for consecutive ints ");
}

void UK2Node_SwitchOnIntArray::CreateSelectionPin()
{
    const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
    UEdGraphPin* Pin = CreatePin(EGPD_Input, GetInnerCaseType().PinCategory, TEXT("Selection"));
    K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
    UE_LOG(LogSwitchOnIntArray, Log, TEXT("Selection pin created: %s"), *Pin->PinName.ToString());
}

FName UK2Node_SwitchOnIntArray::GetPinNameGivenIndex(int32 Index) const
{
    if (Index < 0 || Index >= PinNames.Num())
    {
        return NAME_None;
    }
    return PinNames[Index];
}

FEdGraphPinType UK2Node_SwitchOnIntArray::GetInnerCaseType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Int;
    return PinType;
}

FEdGraphPinType UK2Node_SwitchOnIntArray::GetPinType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Int;
    return PinType;
}

void UK2Node_SwitchOnIntArray::CreateCasePins()
{
    // Make sure we have a name for each pin value
    while (PinValues.Num() > PinNames.Num())
    {
        const FName PinName = GetUniquePinName();
        PinNames.Add(PinName);
    }

    // Trim excess names if we have more names than values
    if (PinNames.Num() > PinValues.Num())
    {
        PinNames.SetNum(PinValues.Num());
    }
    
    UE_LOG(LogSwitchOnIntArray, Log, TEXT("Creating %d case pins"), PinValues.Num());

    // Create a pin for each value
    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {
        UEdGraphPin* Pin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinNames[Index]);
        Pin->bAllowFriendlyName = false;
        Pin->PinFriendlyName = FText::FromString(FString::Printf(TEXT("%d"), PinValues[Index]));
        Pin->SourceIndex = Index;
        
        UE_LOG(LogSwitchOnIntArray, Log, TEXT("  - Pin %d: Name=%s, Value=%d"), 
            Index, *PinNames[Index].ToString(), PinValues[Index]);
    }
}

FName UK2Node_SwitchOnIntArray::GetUniquePinName()
{
    FName NewPinName;
    int32 Index = 0;
    while (true)
    {
        NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
        if (!FindPin(NewPinName))
        {
            break;
        }
    }
    return NewPinName;
}

FString UK2Node_SwitchOnIntArray::GetExportTextForPin(const UEdGraphPin* InPin) const
{
    if (!InPin || InPin->SourceIndex < 0 || InPin->SourceIndex >= PinValues.Num())
    {
        UE_LOG(LogSwitchOnIntArray, Warning, TEXT("Invalid pin or source index for GetExportTextForPin"));
        return TEXT("0");
    }
    int32 Value = PinValues[InPin->SourceIndex];
    FString ExportText = FString::FromInt(Value);
    UE_LOG(LogSwitchOnIntArray, Warning, TEXT("GetExportTextForPin: Pin=%s, Index=%d, Value=%d, ExportText=%s"),
        *InPin->PinName.ToString(), InPin->SourceIndex, Value, *ExportText);
    return ExportText;
}

void UK2Node_SwitchOnIntArray::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
    bool bIsDirty = false;
    FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;

    if (PropertyName == TEXT("PinValues"))
    {
        UE_LOG(LogSwitchOnIntArray, Log, TEXT("PinValues property changed, reconstructing node"));
        bIsDirty = true;
    }

    if (bIsDirty)
    {
        ReconstructNode();
    }
    
    Super::PostEditChangeProperty(PropertyChangedEvent);
    GetGraph()->NotifyNodeChanged(this);
}

void UK2Node_SwitchOnIntArray::ValidateNodeDuringCompilation(FCompilerResultsLog& MessageLog) const
{
    Super::ValidateNodeDuringCompilation(MessageLog);

    // Check for duplicate values which could cause unexpected behavior
    TArray<int32> DuplicateValueIndices;
    TMap<int32, TArray<int32>> ValueToIndicesMap;
    
    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {
        int32 Value = PinValues[Index];
        TArray<int32>& Indices = ValueToIndicesMap.FindOrAdd(Value);
        Indices.Add(Index);
        
        if (Indices.Num() > 1)
        {
            // Only add the first duplicate to avoid multiple warnings for the same value
            if (Indices.Num() == 2)
            {
                DuplicateValueIndices.Add(Indices[0]);
            }
            DuplicateValueIndices.AddUnique(Index);
        }
    }
    
    // Report duplicates as warnings
    if (DuplicateValueIndices.Num() > 0)
    {
        TMap<int32, TArray<int32>> DuplicateGroups;
        for (int32 Index : DuplicateValueIndices)
        {
            int32 Value = PinValues[Index];
            DuplicateGroups.FindOrAdd(Value).Add(Index);
        }
        
        // Build a detailed warning message
        FString WarningMessage = TEXT("Duplicate integer values detected in pin options:\n");
        for (auto& Pair : DuplicateGroups)
        {
            WarningMessage += FString::Printf(TEXT("Value %d appears at indices: "), Pair.Key);
            for (int32 i = 0; i < Pair.Value.Num(); i++)
            {
                WarningMessage += FString::FromInt(Pair.Value[i]);
                if (i < Pair.Value.Num() - 1)
                {
                    WarningMessage += TEXT(", ");
                }
            }
            WarningMessage += TEXT("\n");
        }
        WarningMessage += TEXT("Only the first matching value will be used for execution flow.");
        
        MessageLog.Warning(*FText::FromString(WarningMessage).ToString(), this);
    }

    // ADD DEBUG INSPECTION FOR SELECTION PIN VALUE
    UEdGraphPin* SelectionPin = GetSelectionPin();
    if (SelectionPin && SelectionPin->LinkedTo.Num() > 0)
    {
        UE_LOG(LogSwitchOnIntArray, Warning, TEXT("VALIDATING - Selection pin has %d connections"), SelectionPin->LinkedTo.Num());
        
        // Log details about what's connected to the selection pin
        for (UEdGraphPin* LinkedPin : SelectionPin->LinkedTo)
        {
            UE_LOG(LogSwitchOnIntArray, Warning, TEXT("  - Connected to: %s, PinName=%s"), 
                *GetNameSafe(LinkedPin->GetOwningNode()), *LinkedPin->PinName.ToString());
            
            // If it's coming from a variable getter, show the variable name
            UK2Node_VariableGet* VarNode = Cast<UK2Node_VariableGet>(LinkedPin->GetOwningNode());
            if (VarNode)
            {
                FString VarName = VarNode->GetVarNameString();
                UE_LOG(LogSwitchOnIntArray, Warning, TEXT("    => Variable: %s"), *VarName);
            }
        }
    }
    else
    {
        UE_LOG(LogSwitchOnIntArray, Warning, TEXT("VALIDATING - Selection pin has no connections"));
        if (SelectionPin)
        {
            // Check if there's a default value set
            UE_LOG(LogSwitchOnIntArray, Warning, TEXT("  - Default value: %s"), *SelectionPin->DefaultValue);
        }
    }
}

void UK2Node_SwitchOnIntArray::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
    UE_LOG(LogSwitchOnIntArray, Warning, TEXT("EXPANDING NODE - %s"), *GetName());
    
    UEdGraphPin* SelectionPin = GetSelectionPin();
    if (SelectionPin)
    {
        // Get the net that's feeding into the selection pin
        UEdGraphPin* SelectionNet = FEdGraphUtilities::GetNetFromPin(SelectionPin);
        
        if (SelectionNet)
        {
            UE_LOG(LogSwitchOnIntArray, Warning, TEXT("  - Selection pin connected to net: %s"), *SelectionNet->PinName.ToString());
            
            // Look at the selection pin's value during compilation
            FString PinValue = SelectionPin->DefaultValue;
            UE_LOG(LogSwitchOnIntArray, Warning, TEXT("  - Selection pin default value: %s"), *PinValue);
            
            // If pin is linked to something, trace where it's coming from
            if (SelectionPin->LinkedTo.Num() > 0)
            {
                UEdGraphPin* LinkedPin = SelectionPin->LinkedTo[0];
                UE_LOG(LogSwitchOnIntArray, Warning, TEXT("  - Linked from pin: %s on node %s"), 
                    *LinkedPin->PinName.ToString(), 
                    *GetNameSafe(LinkedPin->GetOwningNode()));
                
                // If it's a variable get node, print details
                UK2Node_VariableGet* VarNode = Cast<UK2Node_VariableGet>(LinkedPin->GetOwningNode());
                if (VarNode)
                {
                    FString VarName = VarNode->GetVarNameString();
                    UE_LOG(LogSwitchOnIntArray, Warning, TEXT("    => Variable: %s"), *VarName);
                    
                    // Get the blueprint that owns this node
                    if (UBlueprint* BP = CompilerContext.Blueprint)
                    {
                        UE_LOG(LogSwitchOnIntArray, Warning, TEXT("    => Blueprint: %s"), *BP->GetName());
                        
                        // Properly look up property using the schema
                        const UEdGraphSchema_K2* Schema = GetDefault<UEdGraphSchema_K2>();
                        bool bIsSparseProperty = false;
                        
                        if (BP->GeneratedClass)
                        {
                            FProperty* VarProperty = FKismetCompilerUtilities::FindPropertyInScope(
                                BP->GeneratedClass, 
                                LinkedPin,
                                CompilerContext.MessageLog, 
                                Schema,
                                BP->GeneratedClass,
                                bIsSparseProperty);
                                
                            if (VarProperty)
                            {
                                UE_LOG(LogSwitchOnIntArray, Warning, TEXT("    => Found variable property: %s"), *VarProperty->GetName());
                            }
                            else
                            {
                                UE_LOG(LogSwitchOnIntArray, Warning, TEXT("    => Could not find variable property"));
                            }
                        }
                    }
                }
            }
            else
            {
                UE_LOG(LogSwitchOnIntArray, Warning, TEXT("  - Selection pin has no incoming links"));
            }
        }
        else
        {
            UE_LOG(LogSwitchOnIntArray, Warning, TEXT("  - Selection pin not connected to any net"));
        }
        
        // Log all PinValues for debugging
        UE_LOG(LogSwitchOnIntArray, Warning, TEXT("Available case values:"));
        for (int32 i = 0; i < PinValues.Num(); ++i)
        {
            UE_LOG(LogSwitchOnIntArray, Warning, TEXT("  - Case %d: Value=%d"), i, PinValues[i]);
        }
    }
    
    // Call the parent implementation to do the actual expansion
    Super::ExpandNode(CompilerContext, SourceGraph);
}


