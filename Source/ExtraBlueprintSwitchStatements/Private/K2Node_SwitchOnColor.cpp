// Copyright Amir Ben-Kiki 2025

#include "K2Node_SwitchOnColor.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "EdGraph/EdGraphNode.h"

#include "Internationalization/Internationalization.h"
#include "UObject/Class.h"
#include "UObject/UnrealType.h"
#include "Logging/LogMacros.h"

// Simple log category
DEFINE_LOG_CATEGORY_STATIC(LogSwitchOnColor, Log, All);

UK2Node_SwitchOnColor::UK2Node_SwitchOnColor()
{
    SetupUseAlpha();
    FunctionClass = UExtraSwitchComparatorsFunctionLibrary::StaticClass();
    UE_LOG(LogSwitchOnColor, Log, TEXT("SwitchOnColor created, UseAlpha=%s"), UseAlpha ? TEXT("true") : TEXT("false"));
}

void UK2Node_SwitchOnColor::SetupUseAlpha()
{
    if (UseAlpha)
    {
        FunctionName = TEXT("IsColorWithToleranceNotNearlyEqual");
    }
    else
    {
        FunctionName = TEXT("IsColorWithToleranceNotNearlyEqualNoAlpha");
    }
    UE_LOG(LogSwitchOnColor, Log, TEXT("SetupUseAlpha: FunctionName set to %s"), *FunctionName.ToString());
}

void UK2Node_SwitchOnColor::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}

FText UK2Node_SwitchOnColor::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    return NSLOCTEXT("K2Node", "Switch_Color", "Switch on Color");
}

inline FText UK2Node_SwitchOnColor::GetTooltipText() const
{
    return INVTEXT("Switch statement using color values and tolerance, \nany execution path that matches the equality condition will execute \nif none do then default will execute");
}

void UK2Node_SwitchOnColor::CreateSelectionPin()
{
    const UEdGraphSchema_K2* K2Schema = GetDefault<USwitchOnColorGraphSchema>();
    UEdGraphPin* Pin = CreatePin(EGPD_Input, USwitchOnColorGraphSchema::PC_Struct, TBaseStructure<FLinearColor>::Get(), TEXT("Selection"));
    K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
    UE_LOG(LogSwitchOnColor, Log, TEXT("Selection pin created: %s"), *Pin->PinName.ToString());
}

FName UK2Node_SwitchOnColor::GetPinNameGivenIndex(int32 Index) const
{
    check(Index);
    return PinNames[Index];
}

FEdGraphPinType UK2Node_SwitchOnColor::GetInnerCaseType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = USwitchOnColorGraphSchema::PC_Struct;
    PinType.PinSubCategoryObject = FColorAndTolerance::StaticStruct();
    return PinType;
}

FEdGraphPinType UK2Node_SwitchOnColor::GetPinType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = USwitchOnColorGraphSchema::PC_Struct;
    PinType.PinSubCategoryObject = TBaseStructure<FLinearColor>::Get();
    return PinType;
}

void UK2Node_SwitchOnColor::CreateCasePins()
{
    while (PinValues.Num() > PinNames.Num())
    {
        const FName PinName = GetUniquePinName();
        PinNames.Add(PinName);
    }

    if (PinNames.Num() > PinValues.Num())
    {
        PinNames.SetNum(PinValues.Num());
    }

    UE_LOG(LogSwitchOnColor, Log, TEXT("Creating %d case pins"), PinValues.Num());

    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {
        UEdGraphPin* Pin = CreatePin(EGPD_Output, USwitchOnColorGraphSchema::PC_Exec, PinNames[Index]);
        Pin->bAllowFriendlyName = false;
        FString ColorHex = PinValues[Index].ToFColor(true).ToHex();
        Pin->PinFriendlyName = FText::FromString(ColorHex);
        Pin->SourceIndex = Index;
        
        UE_LOG(LogSwitchOnColor, Log, TEXT("  - Pin %d: Name=%s, Color=(%f,%f,%f,%f), Hex=%s"), 
            Index, *PinNames[Index].ToString(), 
            PinValues[Index].R, PinValues[Index].G, PinValues[Index].B, PinValues[Index].A,
            *ColorHex);
    }
}

FName UK2Node_SwitchOnColor::GetUniquePinName()
{
    FName NewPinName;
    int32 Index = 0;
    while (true)
    {
        NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
        if (!FindPin(NewPinName))
        {
            break;
        }
    }
    return NewPinName;
}

FString UK2Node_SwitchOnColor::GetExportTextForPin(const UEdGraphPin* InPin) const
{
    FString ExportText = FString::Printf(TEXT("(Color=%s,Tolerance=%3.3f)"), 
        *PinValues[InPin->SourceIndex].ToString(), Distance);
    
    UE_LOG(LogSwitchOnColor, Log, TEXT("ExportTextForPin: %s = %s"), 
        *InPin->PinName.ToString(), *ExportText);
    
    return ExportText;
}

void UK2Node_SwitchOnColor::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
    bool bIsDirty = false;
    FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;
    
    if (PropertyName == TEXT("PinValues") ||
        PropertyName == TEXT("R") || 
        PropertyName == TEXT("G") || 
        PropertyName == TEXT("B") ||
        (PropertyName == TEXT("A") && UseAlpha) ||
        PropertyName == TEXT("Tolerance"))
    {
        bIsDirty = true;
    }

    if (PropertyName == TEXT("UseAlpha"))
    {
        SetupUseAlpha();
        bIsDirty = true;
    }

    if (bIsDirty)
    {
        UE_LOG(LogSwitchOnColor, Log, TEXT("Property changed: %s, reconstructing node"), *PropertyName.ToString());
        ReconstructNode();
    }
    
    Super::PostEditChangeProperty(PropertyChangedEvent);
    GetGraph()->NotifyNodeChanged(this);
}

FLinearColor USwitchOnColorGraphSchema::GetPinTypeColor(const FEdGraphPinType& PinType) const
{
    const FName TypeName = PinType.PinCategory;

    if (TypeName == PC_Exec)
    {
        return FLinearColor::Blue;
    }
    else {
       return Super::GetPinTypeColor(PinType);
    }
}
