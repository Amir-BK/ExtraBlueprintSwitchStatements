// Fill out your copyright notice in the Description page of Project Settings.


#include "K2Node_SwitchOnColor.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "EdGraph/EdGraphNode.h"

#include "Internationalization/Internationalization.h"

#include "UObject/Class.h"

#include "UObject/UnrealType.h"



UK2Node_SwitchOnColor::UK2Node_SwitchOnColor()
{
	//Set the default function name and class, this is the function that will be called when the switch is executed, if it returns true the output pin will be executed
    SetupUseAlpha();
	FunctionClass = UK2Node_SwitchOnColor::StaticClass();

}

void UK2Node_SwitchOnColor::SetupUseAlpha()
{
    if (UseAlpha)
    {
        FunctionName = TEXT("IsColorWithToleranceNotNearlyEqual");
    }
    else
    {
		FunctionName = TEXT("IsColorWithToleranceNotNearlyEqualNoAlpha");
	}
}

void UK2Node_SwitchOnColor::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}

FText UK2Node_SwitchOnColor::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    return NSLOCTEXT("K2Node", "Switch_Color", "Switch on Color");

}


bool UK2Node_SwitchOnColor::IsColorWithToleranceNotNearlyEqualNoAlpha(FLinearColor& A, FColorAndTolerance& B)
{
    //FLinearColor::Dist
    float temp = FLinearColor::Dist(A.HSVToLinearRGB(), B.Color.HSVToLinearRGB());

    if (temp > B.Tolerance)
    {
		return true;
	}
    return false;
}

bool UK2Node_SwitchOnColor::IsColorWithToleranceNotNearlyEqual(FLinearColor& A, FColorAndTolerance& B)
{
    float temp = FLinearColor::Dist(A, B.Color);

    if (temp > B.Tolerance)
    {
        return true;
    }
    return false;

}



inline FText UK2Node_SwitchOnColor::GetTooltipText() const
{
    return INVTEXT("Switch statement using color values and tolerance, \nany execution path that matches the equality condition will execute \nif none do then default will execute");
}



void UK2Node_SwitchOnColor::CreateSelectionPin()
{

    const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
    UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Struct, TBaseStructure<FLinearColor>::Get(), TEXT("Selection"));
    K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);

}



FName UK2Node_SwitchOnColor::GetPinNameGivenIndex(int32 Index) const
{
    check(Index);
    return PinNames[Index];
}

FEdGraphPinType UK2Node_SwitchOnColor::GetInnerCaseType() const
{
	FEdGraphPinType PinType;
	PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
	PinType.PinSubCategoryObject = FColorAndTolerance::StaticStruct();
	return PinType;
}

FEdGraphPinType UK2Node_SwitchOnColor::GetPinType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
    PinType.PinSubCategoryObject = TBaseStructure<FLinearColor>::Get();
    
    return PinType;
}

void UK2Node_SwitchOnColor::CreateCasePins()
{
    while (PinValues.Num() > PinNames.Num())
    {
        const FName PinName = GetUniquePinName();
        PinNames.Add(PinName);
    }

    if (PinNames.Num() > PinValues.Num())
    {
        PinNames.SetNum(PinValues.Num());
    }

    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {

       // PinNames[Index] = PinNames[Index];
     
        // UEdGraphPin* Test = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, TBaseStructure<FVector>::Get(), PinNames[Index]);
         UEdGraphPin* Pin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinNames[Index]);
         Pin->bAllowFriendlyName = false;
         Pin->PinFriendlyName = FText::FromString(PinValues[Index].ToFColor(true).ToHex());
         Pin->SourceIndex = Index;

    }


}



FName UK2Node_SwitchOnColor::GetUniquePinName()
{
    FName NewPinName;
    int32 Index = 0;
    while (true)
    {
        NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
        if (!FindPin(NewPinName))
        {
            break;
        }
    }
    return NewPinName;
}

FString UK2Node_SwitchOnColor::GetExportTextForPin(const UEdGraphPin* InPin) const
{
	
	return FString::Printf(TEXT("(Color=%s,Tolerance=%3.3f)"), *PinValues[InPin->SourceIndex].ToString(), Distance);
}



void UK2Node_SwitchOnColor::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
    bool bIsDirty = false;
    FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;
    if (PropertyName == TEXT("PinValues"))
    {
        bIsDirty = true;
    }

    if (PropertyName == TEXT("R"))
    {
		bIsDirty = true;
	}
    
    if (PropertyName == TEXT("G"))
    {
        bIsDirty = true;    
    }

    if (PropertyName == TEXT("B"))
    {
		bIsDirty = true;
	}

    if (PropertyName == TEXT("A"))
    {
        if(UseAlpha)  bIsDirty = true;
    }

    if (PropertyName == TEXT("Tolerance"))
    {
        bIsDirty = true;
    }

    if (PropertyName == TEXT("UseAlpha"))
    {
        SetupUseAlpha();
        bIsDirty = true;
    }


    if (bIsDirty)
    {
         ReconstructNode();
    }
    Super::PostEditChangeProperty(PropertyChangedEvent);
    GetGraph()->NotifyNodeChanged(this);

}


