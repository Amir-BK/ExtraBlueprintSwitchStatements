// Copyright Amir Ben-Kiki 2025

#include "K2Node_SwitchOnVector.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "EdGraph/EdGraphNode.h"
#include "ExtraSwitchComparatorsFunctionLibrary.h"

#include "KismetCompiler.h"
#include "EdGraphUtilities.h"
#include "Internationalization/Internationalization.h"
#include "UObject/Class.h"
#include "UObject/UnrealType.h"
#include "Logging/LogMacros.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "K2Node_VariableGet.h"

// Simple log category for debugging
DEFINE_LOG_CATEGORY_STATIC(LogSwitchOnVector, Log, All);

UK2Node_SwitchOnVector::UK2Node_SwitchOnVector()
{
    // Set the function name and class to use the static function from ExtraSwitchComparatorsFunctionLibrary
    FunctionName = TEXT("IsVectorWithToleranceNotNearlyEqual");
    FunctionClass = UExtraSwitchComparatorsFunctionLibrary::StaticClass();
    UE_LOG(LogSwitchOnVector, Log, TEXT("SwitchOnVector created"));
}

void UK2Node_SwitchOnVector::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}

FText UK2Node_SwitchOnVector::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    return NSLOCTEXT("K2Node", "Switch_Vector", "Switch on Vector");
}

static bool PointsAreNear(const FVector& Point1, const FVector& Point2, float Dist)
{
    double Temp;
    
    Temp = (Point1.X - Point2.X); if (FMath::Abs(Temp) > Dist) return false;
    Temp = (Point1.Y - Point2.Y); if (FMath::Abs(Temp) > Dist) return false;
    Temp = (Point1.Z - Point2.Z); if (FMath::Abs(Temp) > Dist) return false;
    return true;
}

bool UK2Node_SwitchOnVector::IsVectorWithToleranceNotNearlyEqual(FVector& A, FVectorAndTolerance& B)
{
    // Delegate to the function library implementation
    return UExtraSwitchComparatorsFunctionLibrary::IsVectorWithToleranceNotNearlyEqual(A, B);
}

inline FText UK2Node_SwitchOnVector::GetTooltipText() const
{
    return INVTEXT("Switch statement using vector values and tolerance, \nany execution path that matches the equality condition will execute \nif none do then default will execute");
}

void UK2Node_SwitchOnVector::CreateSelectionPin()
{
    const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
    UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Struct, TBaseStructure<FVector>::Get(), TEXT("Selection"));
    K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
    UE_LOG(LogSwitchOnVector, Log, TEXT("Selection pin created: %s"), *Pin->PinName.ToString());
}

FName UK2Node_SwitchOnVector::GetPinNameGivenIndex(int32 Index) const
{
    check(Index);
    return PinNames[Index];
}

FEdGraphPinType UK2Node_SwitchOnVector::GetInnerCaseType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
    PinType.PinSubCategoryObject = FVectorAndTolerance::StaticStruct();
    return PinType;
}

FEdGraphPinType UK2Node_SwitchOnVector::GetPinType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
    PinType.PinSubCategoryObject = TBaseStructure<FVector>::Get();
    return PinType;
}

void UK2Node_SwitchOnVector::CreateCasePins()
{
    // Clear existing pin names to ensure we create fresh unique names
    PinNames.Empty();

    // Create a unique name for each pin value
    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {
        FName PinName = *FString::Printf(TEXT("Case_%d"), Index);
        PinNames.Add(PinName);
        
        UEdGraphPin* Pin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinName);
        Pin->bAllowFriendlyName = false;
        Pin->PinFriendlyName = FText::FromString(PinValues[Index].ToString());
        Pin->SourceIndex = Index;
        
        UE_LOG(LogSwitchOnVector, Warning, TEXT("Created pin %d: Name=%s, Value=%s"),
            Index, *PinName.ToString(), *PinValues[Index].ToString());
    }
}

FName UK2Node_SwitchOnVector::GetUniquePinName()
{
    FName NewPinName;
    int32 Index = 0;
    while (true)
    {
        NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
        if (!FindPin(NewPinName))
        {
            break;
        }
    }
    return NewPinName;
}

FString UK2Node_SwitchOnVector::GetExportTextForPin(const UEdGraphPin* InPin) const
{
    if (!InPin || InPin->SourceIndex < 0 || InPin->SourceIndex >= PinValues.Num())
    {
        return TEXT("(X=0.000,Y=0.000,Z=0.000,Tolerance=0.100)");
    }

    // Format the vector and tolerance as an FVectorAndTolerance struct
    const FVector& Value = PinValues[InPin->SourceIndex];
    FString ExportText = FString::Printf(TEXT("(X=%3.3f,Y=%3.3f,Z=%3.3f,Tolerance=%3.3f)"), 
        Value.X, Value.Y, Value.Z, Tolerance);
    
    UE_LOG(LogSwitchOnVector, Warning, TEXT("GetExportTextForPin: Pin=%s, Index=%d, Value=%s, Tolerance=%f, ExportText=%s"),
        *InPin->PinName.ToString(), InPin->SourceIndex, *Value.ToString(), Tolerance, *ExportText);
    
    return ExportText;
}

void UK2Node_SwitchOnVector::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
    bool bIsDirty = false;
    FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;
    
    if (PropertyName == TEXT("PinValues"))
    {
        bIsDirty = true;
    }

    if (PropertyName == TEXT("X") || PropertyName == TEXT("Y") || PropertyName == TEXT("Z"))
    {
        bIsDirty = true;
    }

    if (PropertyName == TEXT("Tolerance"))
    {
        bIsDirty = true;
    }

    if (bIsDirty)
    {
        UE_LOG(LogSwitchOnVector, Log, TEXT("Property changed: %s, reconstructing node"), *PropertyName.ToString());
        ReconstructNode();
    }
    Super::PostEditChangeProperty(PropertyChangedEvent);
    GetGraph()->NotifyNodeChanged(this);
}

void UK2Node_SwitchOnVector::ValidateNodeDuringCompilation(FCompilerResultsLog& MessageLog) const
{
    Super::ValidateNodeDuringCompilation(MessageLog);

    // ADD DEBUG INSPECTION FOR SELECTION PIN VALUE
    UEdGraphPin* SelectionPin = GetSelectionPin();
    if (SelectionPin && SelectionPin->LinkedTo.Num() > 0)
    {
        UE_LOG(LogSwitchOnVector, Warning, TEXT("VALIDATING - Selection pin has %d connections"), SelectionPin->LinkedTo.Num());
        
        // Log details about what's connected to the selection pin
        for (UEdGraphPin* LinkedPin : SelectionPin->LinkedTo)
        {
            UE_LOG(LogSwitchOnVector, Warning, TEXT("  - Connected to: %s, PinName=%s"), 
                *GetNameSafe(LinkedPin->GetOwningNode()), *LinkedPin->PinName.ToString());
            
            // If it's coming from a variable getter, show the variable name
            UK2Node_VariableGet* VarNode = Cast<UK2Node_VariableGet>(LinkedPin->GetOwningNode());
            if (VarNode)
            {
                FString VarName = VarNode->GetVarNameString();
                UE_LOG(LogSwitchOnVector, Warning, TEXT("    => Variable: %s"), *VarName);
            }
        }
    }
    else
    {
        UE_LOG(LogSwitchOnVector, Warning, TEXT("VALIDATING - Selection pin has no connections"));
        if (SelectionPin)
        {
            // Check if there's a default value set
            UE_LOG(LogSwitchOnVector, Warning, TEXT("  - Default value: %s"), *SelectionPin->DefaultValue);
        }
    }
}

void UK2Node_SwitchOnVector::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
    UE_LOG(LogSwitchOnVector, Warning, TEXT("ExpandNode called for vector switch"));

    // Call the parent implementation to do the actual expansion
    Super::ExpandNode(CompilerContext, SourceGraph);
}


