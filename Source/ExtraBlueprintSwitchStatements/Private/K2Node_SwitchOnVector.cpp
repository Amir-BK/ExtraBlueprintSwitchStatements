// Copyright Amir Ben-Kiki 2025

#include "K2Node_SwitchOnVector.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "EdGraph/EdGraphNode.h"

#include "Internationalization/Internationalization.h"

#include "UObject/Class.h"

#include "UObject/UnrealType.h"



UK2Node_SwitchOnVector::UK2Node_SwitchOnVector()
{
	//Set the default function name and class, this is the function that will be called when the switch is executed, if it returns true the output pin will be executed
    FunctionName = TEXT("IsVectorWithToleranceNotNearlyEqual");
	FunctionClass = UK2Node_SwitchOnVector::StaticClass();

}

void UK2Node_SwitchOnVector::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}

FText UK2Node_SwitchOnVector::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    return NSLOCTEXT("K2Node", "Switch_Vector", "Switch on Vector");

}


static bool PointsAreNear(const FVector& Point1, const FVector& Point2, float Dist)
{
    double Temp;
    
    Temp = (Point1.X - Point2.X); if (FMath::Abs(Temp) > Dist) return false;
    Temp = (Point1.Y - Point2.Y); if (FMath::Abs(Temp) > Dist) return false;
    Temp = (Point1.Z - Point2.Z); if (FMath::Abs(Temp) > Dist) return false;
    return true;
}

bool UK2Node_SwitchOnVector::IsVectorWithToleranceNotNearlyEqual(FVector& A, FVectorAndTolerance& B)
{
    return !PointsAreNear(A, FVector(B.X, B.Y, B.Z), B.Tolerance);

}

inline FText UK2Node_SwitchOnVector::GetTooltipText() const
{
    return INVTEXT("Switch statement using vector values and tolerance, \nany execution path that matches the equality condition will execute \nif none do then default will execute");
}



void UK2Node_SwitchOnVector::CreateSelectionPin()
{

    const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
    UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Struct, TBaseStructure<FVector>::Get(), TEXT("Selection"));
    K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);

}



FName UK2Node_SwitchOnVector::GetPinNameGivenIndex(int32 Index) const
{
    check(Index);
    return PinNames[Index];
}

FEdGraphPinType UK2Node_SwitchOnVector::GetInnerCaseType() const
{
	FEdGraphPinType PinType;
	PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
	PinType.PinSubCategoryObject = FVectorAndTolerance::StaticStruct();
	return PinType;
}

FEdGraphPinType UK2Node_SwitchOnVector::GetPinType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
    PinType.PinSubCategoryObject = TBaseStructure<FVector>::Get();
    return PinType;
}

void UK2Node_SwitchOnVector::CreateCasePins()
{
    while (PinValues.Num() > PinNames.Num())
    {
        const FName PinName = GetUniquePinName();
        PinNames.Add(PinName);
    }

    if (PinNames.Num() > PinValues.Num())
    {
        PinNames.SetNum(PinValues.Num());
    }

    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {

       // PinNames[Index] = PinNames[Index];

        // UEdGraphPin* Test = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, TBaseStructure<FVector>::Get(), PinNames[Index]);
         UEdGraphPin* Pin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinNames[Index]);
         Pin->bAllowFriendlyName = false;
         Pin->PinFriendlyName = FText::FromString(PinValues[Index].ToString());
         Pin->SourceIndex = Index;

    }


}



FName UK2Node_SwitchOnVector::GetUniquePinName()
{
    FName NewPinName;
    int32 Index = 0;
    while (true)
    {
        NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
        if (!FindPin(NewPinName))
        {
            break;
        }
    }
    return NewPinName;
}

FString UK2Node_SwitchOnVector::GetExportTextForPin(const UEdGraphPin* InPin) const
{
	
	return FString::Printf(TEXT("(X=%3.3f,Y=%3.3f,Z=%3.3f,Tolerance=%3.3f)"), PinValues[InPin->SourceIndex].X, PinValues[InPin->SourceIndex].Y, PinValues[InPin->SourceIndex].Z, Tolerance);
}



void UK2Node_SwitchOnVector::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
    bool bIsDirty = false;
    FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;
    if (PropertyName == TEXT("PinValues"))
    {
        bIsDirty = true;
    }

    if (PropertyName == TEXT("X"))
    {
		bIsDirty = true;
	}
    
    if (PropertyName == TEXT("Y"))
    {
        bIsDirty = true;    
    }

    if (PropertyName == TEXT("Z"))
    {
		bIsDirty = true;
	}

    if (PropertyName == TEXT("Tolerance"))
    {
        bIsDirty = true;
    }


    if (bIsDirty)
    {
         ReconstructNode();
    }
    Super::PostEditChangeProperty(PropertyChangedEvent);
    GetGraph()->NotifyNodeChanged(this);

}


