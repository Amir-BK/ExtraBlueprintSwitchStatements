// Copyright Amir Ben-Kiki 2025

#include "K2Node_SwitchOnFloat.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "EdGraph/EdGraphNode.h"

#include "KismetCompiler.h"
#include "EdGraphUtilities.h"
#include "Internationalization/Internationalization.h"
#include "UObject/Class.h"
#include "UObject/UnrealType.h"
#include "Logging/LogMacros.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "K2Node_VariableGet.h"  // Added include for UK2Node_VariableGet

// Simple log category
DEFINE_LOG_CATEGORY_STATIC(LogSwitchOnFloat, Log, All);

UK2Node_SwitchOnFloat::UK2Node_SwitchOnFloat()
{
    // Set the default function name and class
    FunctionName = TEXT("IsFloatWithToleranceNotNearlyEqual");
    FunctionClass = UExtraSwitchComparatorsFunctionLibrary::StaticClass();
    UE_LOG(LogSwitchOnFloat, Log, TEXT("SwitchOnFloat created"));
}

void UK2Node_SwitchOnFloat::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}

FText UK2Node_SwitchOnFloat::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    return NSLOCTEXT("K2Node", "Switch_Float", "Switch on Float");
}

inline FText UK2Node_SwitchOnFloat::GetTooltipText() const
{
    return INVTEXT("Switch statement using float values and tolerance, \nany execution path that matches the equality condition will execute \nif none do then default will execute");
}

void UK2Node_SwitchOnFloat::CreateSelectionPin()
{
    UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Real, TEXT("Selection"));
    // Remove subcategory override to avoid type mismatch issues
    GetDefault<UEdGraphSchema_K2>()->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
    UE_LOG(LogSwitchOnFloat, Log, TEXT("Selection pin created: %s"), *Pin->PinName.ToString());
}

FName UK2Node_SwitchOnFloat::GetPinNameGivenIndex(int32 Index) const
{
    check(Index);
    return PinNames[Index];
}

FEdGraphPinType UK2Node_SwitchOnFloat::GetInnerCaseType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
    PinType.PinSubCategoryObject = FFloatAndTolerance::StaticStruct();
    return PinType;
}

FEdGraphPinType UK2Node_SwitchOnFloat::GetPinType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Real;
    // Remove subcategory to match CreateSelectionPin behavior
    return PinType;
}

void UK2Node_SwitchOnFloat::CreateCasePins()
{
    // Clear existing pin names to ensure we create fresh unique names
    PinNames.Empty();

    // Create a unique name for each pin value
    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {
        FName PinName = *FString::Printf(TEXT("Case_%d"), Index);
        PinNames.Add(PinName);
        
        UEdGraphPin* Pin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinName);
        Pin->bAllowFriendlyName = false;
        Pin->PinFriendlyName = FText::FromString(FString::Printf(TEXT("%f"), PinValues[Index]));
        Pin->SourceIndex = Index;
        
        UE_LOG(LogSwitchOnFloat, Warning, TEXT("Created pin %d: Name=%s, Value=%f"),
            Index, *PinName.ToString(), PinValues[Index]);
    }
}

FName UK2Node_SwitchOnFloat::GetUniquePinName()
{
    FName NewPinName;
    int32 Index = 0;
    while (true)
    {
        NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
        if (!FindPin(NewPinName))
        {
            break;
        }
    }
    return NewPinName;
}

FString UK2Node_SwitchOnFloat::GetExportTextForPin(const UEdGraphPin* InPin) const
{
    // Use "Value" with a capital V to match UE's property naming convention
    FString ExportText = FString::Printf(TEXT("(Value=%f,Tolerance=%f)"), PinValues[InPin->SourceIndex], Tolerance);
    
    UE_LOG(LogSwitchOnFloat, Warning, TEXT("GetExportTextForPin: Pin=%s, Index=%d, Value=%f, Tolerance=%f, ExportText=%s"),
        *InPin->PinName.ToString(), InPin->SourceIndex, PinValues[InPin->SourceIndex], Tolerance, *ExportText);
    
    return ExportText;
}

void UK2Node_SwitchOnFloat::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
    bool bIsDirty = false;
    FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;

    if (PropertyName == TEXT("PinValues"))
    {
        bIsDirty = true;
    }

    if (PropertyName == TEXT("Tolerance"))
    {
        bIsDirty = true;
    }

    if (bIsDirty)
    {
        UE_LOG(LogSwitchOnFloat, Log, TEXT("Property changed: %s, reconstructing node"), *PropertyName.ToString());
        ReconstructNode();
    }
    Super::PostEditChangeProperty(PropertyChangedEvent);
    GetGraph()->NotifyNodeChanged(this);
}

