// Copyright Amir Ben-Kiki 2025

#include "K2Node_SwitchOnFloat.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "EdGraph/EdGraphNode.h"

#include "KismetCompiler.h"
#include "EdGraphUtilities.h"
#include "Internationalization/Internationalization.h"
#include "UObject/Class.h"
#include "UObject/UnrealType.h"
#include "Logging/LogMacros.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "K2Node_VariableGet.h"  // Added include for UK2Node_VariableGet

// Simple log category
DEFINE_LOG_CATEGORY_STATIC(LogSwitchOnFloat, Log, All);

UK2Node_SwitchOnFloat::UK2Node_SwitchOnFloat()
{
    // Set the default function name and class
    FunctionName = TEXT("IsFloatWithToleranceNotNearlyEqual");
    FunctionClass = UExtraSwitchComparatorsFunctionLibrary::StaticClass();
    UE_LOG(LogSwitchOnFloat, Log, TEXT("SwitchOnFloat created"));
}

void UK2Node_SwitchOnFloat::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}

FText UK2Node_SwitchOnFloat::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    return NSLOCTEXT("K2Node", "Switch_Float", "Switch on Float");
}

inline FText UK2Node_SwitchOnFloat::GetTooltipText() const
{
    return INVTEXT("Switch statement using float values and tolerance, \nany execution path that matches the equality condition will execute \nif none do then default will execute");
}

void UK2Node_SwitchOnFloat::CreateSelectionPin()
{
    UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Real, TEXT("Selection"));
    // Remove subcategory override to avoid type mismatch issues
    GetDefault<UEdGraphSchema_K2>()->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
    UE_LOG(LogSwitchOnFloat, Log, TEXT("Selection pin created: %s"), *Pin->PinName.ToString());
}

FName UK2Node_SwitchOnFloat::GetPinNameGivenIndex(int32 Index) const
{
    check(Index);
    return PinNames[Index];
}

FEdGraphPinType UK2Node_SwitchOnFloat::GetInnerCaseType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
    PinType.PinSubCategoryObject = FFloatAndTolerance::StaticStruct();
    return PinType;
}

FEdGraphPinType UK2Node_SwitchOnFloat::GetPinType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Real;
    // Remove subcategory to match CreateSelectionPin behavior
    return PinType;
}

void UK2Node_SwitchOnFloat::CreateCasePins()
{
    // Clear existing pin names to ensure we create fresh unique names
    PinNames.Empty();

    // Create a unique name for each pin value
    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {
        FName PinName = *FString::Printf(TEXT("Case_%d"), Index);
        PinNames.Add(PinName);
        
        UEdGraphPin* Pin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinName);
        Pin->bAllowFriendlyName = false;
        Pin->PinFriendlyName = FText::FromString(FString::Printf(TEXT("%f"), PinValues[Index]));
        Pin->SourceIndex = Index;
        
        UE_LOG(LogSwitchOnFloat, Warning, TEXT("Created pin %d: Name=%s, Value=%f"),
            Index, *PinName.ToString(), PinValues[Index]);
    }
}

FName UK2Node_SwitchOnFloat::GetUniquePinName()
{
    FName NewPinName;
    int32 Index = 0;
    while (true)
    {
        NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
        if (!FindPin(NewPinName))
        {
            break;
        }
    }
    return NewPinName;
}

FString UK2Node_SwitchOnFloat::GetExportTextForPin(const UEdGraphPin* InPin) const
{
    // Use "Value" with a capital V to match UE's property naming convention
    FString ExportText = FString::Printf(TEXT("(Value=%f,Tolerance=%f)"), PinValues[InPin->SourceIndex], Tolerance);
    
    UE_LOG(LogSwitchOnFloat, Warning, TEXT("GetExportTextForPin: Pin=%s, Index=%d, Value=%f, Tolerance=%f, ExportText=%s"),
        *InPin->PinName.ToString(), InPin->SourceIndex, PinValues[InPin->SourceIndex], Tolerance, *ExportText);
    
    return ExportText;
}

void UK2Node_SwitchOnFloat::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
    bool bIsDirty = false;
    FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;

    if (PropertyName == TEXT("PinValues"))
    {
        bIsDirty = true;
    }

    if (PropertyName == TEXT("Tolerance"))
    {
        bIsDirty = true;
    }

    if (bIsDirty)
    {
        UE_LOG(LogSwitchOnFloat, Log, TEXT("Property changed: %s, reconstructing node"), *PropertyName.ToString());
        ReconstructNode();
    }
    Super::PostEditChangeProperty(PropertyChangedEvent);
    GetGraph()->NotifyNodeChanged(this);
}

void UK2Node_SwitchOnFloat::ValidateNodeDuringCompilation(FCompilerResultsLog& MessageLog) const
{
    Super::ValidateNodeDuringCompilation(MessageLog);

    // ADD DEBUG INSPECTION FOR SELECTION PIN VALUE
    UEdGraphPin* SelectionPin = GetSelectionPin();
    if (SelectionPin && SelectionPin->LinkedTo.Num() > 0)
    {
        UE_LOG(LogSwitchOnFloat, Warning, TEXT("VALIDATING - Selection pin has %d connections"), SelectionPin->LinkedTo.Num());
        
        // Log details about what's connected to the selection pin
        for (UEdGraphPin* LinkedPin : SelectionPin->LinkedTo)
        {
            UE_LOG(LogSwitchOnFloat, Warning, TEXT("  - Connected to: %s, PinName=%s"), 
                *GetNameSafe(LinkedPin->GetOwningNode()), *LinkedPin->PinName.ToString());
            
            // If it's coming from a variable getter, show the variable name
            UK2Node_VariableGet* VarNode = Cast<UK2Node_VariableGet>(LinkedPin->GetOwningNode());
            if (VarNode)
            {
                FString VarName = VarNode->GetVarNameString();
                UE_LOG(LogSwitchOnFloat, Warning, TEXT("    => Variable: %s"), *VarName);
            }
        }
    }
    else
    {
        UE_LOG(LogSwitchOnFloat, Warning, TEXT("VALIDATING - Selection pin has no connections"));
        if (SelectionPin)
        {
            // Check if there's a default value set
            UE_LOG(LogSwitchOnFloat, Warning, TEXT("  - Default value: %s"), *SelectionPin->DefaultValue);
        }
    }
}

void UK2Node_SwitchOnFloat::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
    UEdGraphPin* SelectionPin = GetSelectionPin();
    if (SelectionPin)
    {
        // Get the net that's feeding into the selection pin
        UEdGraphPin* SelectionNet = FEdGraphUtilities::GetNetFromPin(SelectionPin);
        
        if (SelectionNet)
        {
            UE_LOG(LogSwitchOnFloat, Warning, TEXT("EXPANDING NODE - Selection pin connected to net: %s"), *SelectionNet->PinName.ToString());
            
            // Look at the selection pin's value during compilation
            FString PinValue = SelectionPin->DefaultValue;
            UE_LOG(LogSwitchOnFloat, Warning, TEXT("  - Selection pin default value: %s"), *PinValue);
            
            // If pin is linked to something, trace where it's coming from
            if (SelectionPin->LinkedTo.Num() > 0)
            {
                UEdGraphPin* LinkedPin = SelectionPin->LinkedTo[0];
                UE_LOG(LogSwitchOnFloat, Warning, TEXT("  - Linked from pin: %s on node %s"), 
                    *LinkedPin->PinName.ToString(), 
                    *GetNameSafe(LinkedPin->GetOwningNode()));
                
                // If it's a variable get node, print details
                UK2Node_VariableGet* VarNode = Cast<UK2Node_VariableGet>(LinkedPin->GetOwningNode());
                if (VarNode)
                {
                    FString VarName = VarNode->GetVarNameString();
                    UE_LOG(LogSwitchOnFloat, Warning, TEXT("    => Variable: %s"), *VarName);
                    
                    // Get the blueprint that owns this node
                    if (UBlueprint* BP = CompilerContext.Blueprint)
                    {
                        UE_LOG(LogSwitchOnFloat, Warning, TEXT("    => Blueprint: %s"), *BP->GetName());
                        
                        // Properly look up property using the schema
                        const UEdGraphSchema_K2* Schema = GetDefault<UEdGraphSchema_K2>();
                        bool bIsSparseProperty = false;
                        
                        if (BP->GeneratedClass)
                        {
                            FProperty* VarProperty = FKismetCompilerUtilities::FindPropertyInScope(
                                BP->GeneratedClass, 
                                LinkedPin,
                                CompilerContext.MessageLog, 
                                Schema,
                                BP->GeneratedClass,
                                bIsSparseProperty);
                                
                            if (VarProperty)
                            {
                                UE_LOG(LogSwitchOnFloat, Warning, TEXT("    => Found variable property: %s"), *VarProperty->GetName());
                            }
                            else
                            {
                                UE_LOG(LogSwitchOnFloat, Warning, TEXT("    => Could not find variable property"));
                            }
                        }
                    }
                }
            }
            else
            {
                UE_LOG(LogSwitchOnFloat, Warning, TEXT("  - Selection pin has no incoming links"));
            }
        }
        else
        {
            UE_LOG(LogSwitchOnFloat, Warning, TEXT("EXPANDING NODE - Selection pin not connected to any net"));
        }
    }
    
    // Call the parent implementation to do the actual expansion
    Super::ExpandNode(CompilerContext, SourceGraph);
}
