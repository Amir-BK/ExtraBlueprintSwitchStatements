// Copyright Amir Ben-Kiki 2025

#include "K2Node_SwitchOnFloat.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "EdGraph/EdGraphNode.h"

#include "Internationalization/Internationalization.h"

#include "UObject/Class.h"

#include "UObject/UnrealType.h"



UK2Node_SwitchOnFloat::UK2Node_SwitchOnFloat()
{
	//Set the default function name and class, this is the function that will be called when the switch is executed, if it returns true the output pin will be executed
    FunctionName = TEXT("IsFloatWithToleranceNotNearlyEqual");
	FunctionClass = UK2Node_SwitchOnFloat::StaticClass();

}

void UK2Node_SwitchOnFloat::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}

FText UK2Node_SwitchOnFloat::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    return NSLOCTEXT("K2Node", "Switch_Float", "Switch on Float");

}


static bool FloatsAreNear(const FVector& Point1, const FVector& Point2, float Dist)
{
    double Temp;
    
    Temp = (Point1.X - Point2.X); if (FMath::Abs(Temp) > Dist) return false;
    Temp = (Point1.Y - Point2.Y); if (FMath::Abs(Temp) > Dist) return false;
    Temp = (Point1.Z - Point2.Z); if (FMath::Abs(Temp) > Dist) return false;
    return true;
}

bool UK2Node_SwitchOnFloat::IsFloatWithToleranceNotNearlyEqual(double& A, FFloatAndTolerance& B)
{
    // Convert double to float for comparison
    float FloatValue = (float)A;
    return !FMath::IsNearlyEqual(FloatValue, B.value, B.Tolerance);
        //!FloatsAreNear(A, FVector(B.value, B.value, B.value), B.Tolerance);

}

inline FText UK2Node_SwitchOnFloat::GetTooltipText() const
{
    return INVTEXT("Switch statement using float values and tolerance, \nany execution path that matches the equality condition will execute \nif none do then default will execute");
}



void UK2Node_SwitchOnFloat::CreateSelectionPin()
{

    UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Real, TEXT("Selection"));
    // Remove subcategory override to avoid type mismatch issues
    GetDefault<UEdGraphSchema_K2>()->SetPinAutogeneratedDefaultValueBasedOnType(Pin);

}



FName UK2Node_SwitchOnFloat::GetPinNameGivenIndex(int32 Index) const
{
    check(Index);
    return PinNames[Index];
}

FEdGraphPinType UK2Node_SwitchOnFloat::GetInnerCaseType() const
{
	FEdGraphPinType PinType;
	PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
	PinType.PinSubCategoryObject = FFloatAndTolerance::StaticStruct();
	return PinType;
}

FEdGraphPinType UK2Node_SwitchOnFloat::GetPinType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Real;
    // Remove subcategory to match CreateSelectionPin behavior
    return PinType;
}

void UK2Node_SwitchOnFloat::CreateCasePins()
{
    while (PinValues.Num() > PinNames.Num())
    {
        const FName PinName = GetUniquePinName();
        PinNames.Add(PinName);
    }

    if (PinNames.Num() > PinValues.Num())
    {
        PinNames.SetNum(PinValues.Num());
    }

    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {

         UEdGraphPin* Pin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinNames[Index]);
         Pin->bAllowFriendlyName = false;
         Pin->PinFriendlyName = FText::FromString(FString::Printf(TEXT("%.3f"), PinValues[Index]));
         Pin->SourceIndex = Index;

    }


}



FName UK2Node_SwitchOnFloat::GetUniquePinName()
{
    FName NewPinName;
    int32 Index = 0;
    while (true)
    {
        NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
        if (!FindPin(NewPinName))
        {
            break;
        }
    }
    return NewPinName;
}

FString UK2Node_SwitchOnFloat::GetExportTextForPin(const UEdGraphPin* InPin) const
{
	
	return FString::Printf(TEXT("(value=%f,Tolerance=%f)"), PinValues[InPin->SourceIndex], Tolerance);
}



void UK2Node_SwitchOnFloat::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
    bool bIsDirty = false;
    FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;

    if (PropertyName == TEXT("PinValues"))
    {
        bIsDirty = true;
    }

    if (PropertyName == TEXT("Tolerance"))
    {
        bIsDirty = true;
    }

    if (bIsDirty)
    {
         ReconstructNode();
    }
    Super::PostEditChangeProperty(PropertyChangedEvent);
    GetGraph()->NotifyNodeChanged(this);

}


