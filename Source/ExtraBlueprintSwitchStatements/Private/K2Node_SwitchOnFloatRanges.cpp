// Copyright Amir Ben-Kiki 2025

#include "K2Node_SwitchOnFloatRanges.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "EdGraph/EdGraphNode.h"
#include "KismetCompiler.h"
#include "EdGraphUtilities.h"
#include "Internationalization/Internationalization.h"
#include "UObject/Class.h"
#include "UObject/UnrealType.h"
#include "Logging/LogMacros.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "K2Node_VariableGet.h"  // Added include for UK2Node_VariableGet
#include "Engine/Engine.h"

// Simple log category
DEFINE_LOG_CATEGORY_STATIC(LogSwitchOnFloatRanges, Log, All);

UK2Node_SwitchOnFloatRanges::UK2Node_SwitchOnFloatRanges()
{
    FunctionName = TEXT("IsFloatNotWithinRange");
    FunctionClass = UExtraSwitchComparatorsFunctionLibrary::StaticClass();
    UE_LOG(LogSwitchOnFloatRanges, Log, TEXT("SwitchOnFloatRanges created"));
}

void UK2Node_SwitchOnFloatRanges::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}

FText UK2Node_SwitchOnFloatRanges::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    return INVTEXT("Switch on Float Range");
}

inline FText UK2Node_SwitchOnFloatRanges::GetTooltipText() const
{
    return INVTEXT("Switch statement using float ranges, \nany execution path that matches the range condition will execute \nif none do then default will execute");
}

void UK2Node_SwitchOnFloatRanges::CreateSelectionPin()
{
    const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
    UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Real, TEXT("Selection"));
    K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
    UE_LOG(LogSwitchOnFloatRanges, Log, TEXT("Selection pin created: %s"), *Pin->PinName.ToString());
}

FName UK2Node_SwitchOnFloatRanges::GetPinNameGivenIndex(int32 Index) const
{
    if (Index < 0 || Index >= PinNames.Num())
    {
        return NAME_None;
    }
    return PinNames[Index];
}

FEdGraphPinType UK2Node_SwitchOnFloatRanges::GetInnerCaseType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
    PinType.PinSubCategoryObject = FExtraSwitchFloatRange::StaticStruct();
    return PinType;
}

FEdGraphPinType UK2Node_SwitchOnFloatRanges::GetPinType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Real;
    return PinType;
}

void UK2Node_SwitchOnFloatRanges::CreateCasePins()
{
    while (PinValues.Num() > PinNames.Num())
    {
        const FName PinName = GetUniquePinName();
        PinNames.Add(PinName);
    }

    if (PinNames.Num() > PinValues.Num())
    {
        PinNames.SetNum(PinValues.Num());
    }

    UE_LOG(LogSwitchOnFloatRanges, Log, TEXT("Creating %d case pins"), PinValues.Num());

    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {
        UEdGraphPin* Pin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinNames[Index]);

        FString DisplayText;
        if (PinValues[Index].Inclusive)
        {
            DisplayText = FString::Printf(TEXT("[%.3f,%.3f]"), PinValues[Index].RangeMin, PinValues[Index].RangeMax);
        }
        else
        {
            DisplayText = FString::Printf(TEXT("(%.3f,%.3f)"), PinValues[Index].RangeMin, PinValues[Index].RangeMax);
        }
        
        Pin->PinFriendlyName = FText::FromString(DisplayText);
        Pin->SourceIndex = Index;
        
        UE_LOG(LogSwitchOnFloatRanges, Log, TEXT("  - Pin %d: Name=%s, Range=%s, Min=%.3f, Max=%.3f, Inclusive=%s"), 
            Index, *PinNames[Index].ToString(), *DisplayText,
            PinValues[Index].RangeMin, PinValues[Index].RangeMax,
            PinValues[Index].Inclusive ? TEXT("true") : TEXT("false"));
    }
}

FName UK2Node_SwitchOnFloatRanges::GetUniquePinName()
{
    FName NewPinName;
    int32 Index = 0;
    while (true)
    {
        NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
        if (!FindPin(NewPinName))
        {
            break;
        }
    }
    return NewPinName;
}

FString UK2Node_SwitchOnFloatRanges::GetExportTextForPin(const UEdGraphPin* InPin) const
{
    if (!InPin || InPin->SourceIndex < 0 || InPin->SourceIndex >= PinValues.Num())
    {
        UE_LOG(LogSwitchOnFloatRanges, Warning, TEXT("Invalid pin or source index for ExportTextForPin"));
        return FString();
    }
    
    FString ExportText = FString::Printf(TEXT("(RangeMax=%f,RangeMin=%f,Inclusive=%s)"), 
                                       PinValues[InPin->SourceIndex].RangeMax, 
                                       PinValues[InPin->SourceIndex].RangeMin,
                                       PinValues[InPin->SourceIndex].Inclusive ? TEXT("true") : TEXT("false"));
    
    UE_LOG(LogSwitchOnFloatRanges, Log, TEXT("ExportTextForPin: %s = %s"), 
        *InPin->PinName.ToString(), *ExportText);
    
    return ExportText;
}

void UK2Node_SwitchOnFloatRanges::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
    bool bIsDirty = false;
    FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;

    if (PropertyName == TEXT("PinValues") || 
        PropertyName == TEXT("RangeMax") || 
        PropertyName == TEXT("RangeMin") || 
        PropertyName == TEXT("Inclusive"))
    {
        bIsDirty = true;
    }

    if (bIsDirty)
    {
        UE_LOG(LogSwitchOnFloatRanges, Log, TEXT("Property changed: %s, reconstructing node"), *PropertyName.ToString());
        ReconstructNode();
    }
    Super::PostEditChangeProperty(PropertyChangedEvent);
    GetGraph()->NotifyNodeChanged(this);
}

void UK2Node_SwitchOnFloatRanges::ValidateNodeDuringCompilation(class FCompilerResultsLog& MessageLog) const
{
    Super::ValidateNodeDuringCompilation(MessageLog);

    // ADD DEBUG INSPECTION FOR SELECTION PIN VALUE
    UEdGraphPin* SelectionPin = GetSelectionPin();
    if (SelectionPin && SelectionPin->LinkedTo.Num() > 0)
    {
        UE_LOG(LogSwitchOnFloatRanges, Warning, TEXT("VALIDATING - Selection pin has %d connections"), SelectionPin->LinkedTo.Num());
        
        // Log details about what's connected to the selection pin
        for (UEdGraphPin* LinkedPin : SelectionPin->LinkedTo)
        {
            UE_LOG(LogSwitchOnFloatRanges, Warning, TEXT("  - Connected to: %s, PinName=%s"), 
                *GetNameSafe(LinkedPin->GetOwningNode()), *LinkedPin->PinName.ToString());
            
            // If it's coming from a variable getter, show the variable name
            UK2Node_VariableGet* VarNode = Cast<UK2Node_VariableGet>(LinkedPin->GetOwningNode());
            if (VarNode)
            {
                FString VarName = VarNode->GetVarNameString();
                UE_LOG(LogSwitchOnFloatRanges, Warning, TEXT("    => Variable: %s"), *VarName);
            }
        }
    }
    else
    {
        UE_LOG(LogSwitchOnFloatRanges, Warning, TEXT("VALIDATING - Selection pin has no connections"));
        if (SelectionPin)
        {
            // Check if there's a default value set
            UE_LOG(LogSwitchOnFloatRanges, Warning, TEXT("  - Default value: %s"), *SelectionPin->DefaultValue);
        }
    }

    TArray<int> InvalidRangePinIndex;
    TArray<int> ReversedRangePinIndex;
    
    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {
        // Check for reversed ranges (min > max)
        if (PinValues[Index].RangeMin > PinValues[Index].RangeMax)
        {
            ReversedRangePinIndex.Add(Index);
            UE_LOG(LogSwitchOnFloatRanges, Warning, TEXT("Reversed range at pin %d: Min(%.3f) > Max(%.3f)"),
                Index, PinValues[Index].RangeMin, PinValues[Index].RangeMax);
        }
        
        TRange<float> Range = TRange<float>();
        Range = PinValues[Index].Inclusive ? 
            Range.Inclusive(PinValues[Index].RangeMin, PinValues[Index].RangeMax) : 
            Range.Exclusive(PinValues[Index].RangeMin, PinValues[Index].RangeMax);

        if (Range.IsEmpty())
        {
            InvalidRangePinIndex.Add(Index);
            UE_LOG(LogSwitchOnFloatRanges, Warning, TEXT("Empty range at pin %d: Min=%.3f, Max=%.3f, Inclusive=%s"),
                Index, PinValues[Index].RangeMin, PinValues[Index].RangeMax, 
                PinValues[Index].Inclusive ? TEXT("true") : TEXT("false"));
        }
    }

    // Report reversed ranges
    if (ReversedRangePinIndex.Num() > 0)
    {
        FString WarningPins = TEXT("");
        for (int32 Index = 0; Index < ReversedRangePinIndex.Num(); ++Index)
        {
            WarningPins += FString::FromInt(ReversedRangePinIndex[Index]);
            if (Index < ReversedRangePinIndex.Num() - 1)
            {
                WarningPins += TEXT(", ");
            }
        }
        MessageLog.Error(*FText::Format(INVTEXT("@@ : Reversed range detected (Min > Max) in pin(s): {0}"), FText::FromString(WarningPins)).ToString(), this);
    }

    // Report empty ranges
    if (InvalidRangePinIndex.Num() > 0)
    {
        FString WarningPins = TEXT("");
        for (int32 Index = 0; Index < InvalidRangePinIndex.Num(); ++Index)
        {
            WarningPins += FString::FromInt(InvalidRangePinIndex[Index]);
            if (Index < InvalidRangePinIndex.Num() - 1)
            {
                WarningPins += TEXT(", ");
            }
        }
        MessageLog.Warning(*FText::Format(INVTEXT("@@ : Empty range detected in pin(s): {0}"), FText::FromString(WarningPins)).ToString(), this);
    }
}



























