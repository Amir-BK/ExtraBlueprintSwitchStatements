// Copyright Amir Ben-Kiki 2025

#include "K2Node_SwitchOnIntRanges.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "EdGraph/EdGraphNode.h"
#include "KismetCompiler.h"
#include "EdGraphUtilities.h"
#include "Internationalization/Internationalization.h"
#include "UObject/Class.h"
#include "UObject/UnrealType.h"
#include "Logging/LogMacros.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "K2Node_VariableGet.h"
#include "Engine/Engine.h"

// Simple log category
DEFINE_LOG_CATEGORY_STATIC(LogSwitchOnIntRanges, Log, All);

UK2Node_SwitchOnIntRanges::UK2Node_SwitchOnIntRanges()
{
    // Set the default function name and class, this is the function that will be called when the switch is executed, if it returns true the output pin will be executed
    FunctionName = TEXT("IsIntNotWithinRange");
    FunctionClass = UK2Node_SwitchOnIntRanges::StaticClass();
    UE_LOG(LogSwitchOnIntRanges, Log, TEXT("SwitchOnIntRanges created"));
}

void UK2Node_SwitchOnIntRanges::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}

FText UK2Node_SwitchOnIntRanges::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    return INVTEXT("Switch on Int Range");
}

bool UK2Node_SwitchOnIntRanges::IsIntNotWithinRange(int& A, FSwitchIntRange& B)
{
    // Log the input values for debugging
    UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("IsIntNotWithinRange CALLED - A=%d, Range=(%d,%d), Inclusive=%s"), 
        A, B.RangeMin, B.RangeMax, B.Inclusive ? TEXT("true") : TEXT("false"));
        
    // Create the range
    TRange<int> Range = TRange<int>();
    Range = B.Inclusive ? Range.Inclusive(B.RangeMin, B.RangeMax) : Range.Exclusive(B.RangeMin, B.RangeMax);
    
    // Check if the value is NOT within the range (return true to skip this pin in the UK2Node_Switch)
    bool bContains = Range.Contains(A);
    bool bNotWithinRange = !bContains;
    
    UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("  - Range%s=(%d,%d), Value=%d, Contains=%s, Result=%s"),
        B.Inclusive ? TEXT("[inclusive]") : TEXT("(exclusive)"), 
        B.RangeMin, B.RangeMax, A, 
        bContains ? TEXT("true") : TEXT("false"), 
        bNotWithinRange ? TEXT("true") : TEXT("false"));
    
    return bNotWithinRange;
}

inline FText UK2Node_SwitchOnIntRanges::GetTooltipText() const
{
    return INVTEXT("Switch statement using integer ranges, \nany execution path that matches the equality condition will execute \nif none do then default will execute");
}

void UK2Node_SwitchOnIntRanges::CreateSelectionPin()
{
    const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
    UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Int, TEXT("Selection"));
    K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
    UE_LOG(LogSwitchOnIntRanges, Log, TEXT("Selection pin created: %s"), *Pin->PinName.ToString());
}

FName UK2Node_SwitchOnIntRanges::GetPinNameGivenIndex(int32 Index) const
{
    if (Index < 0 || Index >= PinNames.Num())
    {
        return NAME_None;
    }
    return PinNames[Index];
}

FEdGraphPinType UK2Node_SwitchOnIntRanges::GetInnerCaseType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
    PinType.PinSubCategoryObject = FSwitchIntRange::StaticStruct();
    return PinType;
}

FEdGraphPinType UK2Node_SwitchOnIntRanges::GetPinType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Int;
    return PinType;
}

void UK2Node_SwitchOnIntRanges::CreateCasePins()
{
    // Make sure we have a name for each pin value
    while (PinValues.Num() > PinNames.Num())
    {
        const FName PinName = GetUniquePinName();
        PinNames.Add(PinName);
    }

    // Trim excess names if we have more names than values
    if (PinNames.Num() > PinValues.Num())
    {
        PinNames.SetNum(PinValues.Num());
    }
    
    UE_LOG(LogSwitchOnIntRanges, Log, TEXT("Creating %d case pins"), PinValues.Num());

    // Create a pin for each range
    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {
        UEdGraphPin* Pin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinNames[Index]);
        
        FString DisplayText;
        if (PinValues[Index].Inclusive)
        {
            DisplayText = FString::Printf(TEXT("[%d,%d]"), PinValues[Index].RangeMin, PinValues[Index].RangeMax);
        }
        else
        {
            DisplayText = FString::Printf(TEXT("(%d,%d)"), PinValues[Index].RangeMin, PinValues[Index].RangeMax);
        }
        
        Pin->PinFriendlyName = FText::FromString(DisplayText);
        Pin->SourceIndex = Index;
        
        UE_LOG(LogSwitchOnIntRanges, Log, TEXT("  - Pin %d: Name=%s, Range=%s, Min=%d, Max=%d, Inclusive=%s"), 
            Index, *PinNames[Index].ToString(), *DisplayText,
            PinValues[Index].RangeMin, PinValues[Index].RangeMax,
            PinValues[Index].Inclusive ? TEXT("true") : TEXT("false"));
    }
}

FName UK2Node_SwitchOnIntRanges::GetUniquePinName()
{
    FName NewPinName;
    int32 Index = 0;
    while (true)
    {
        NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
        if (!FindPin(NewPinName))
        {
            break;
        }
    }
    return NewPinName;
}

FString UK2Node_SwitchOnIntRanges::GetExportTextForPin(const UEdGraphPin* InPin) const
{
    if (!InPin || InPin->SourceIndex < 0 || InPin->SourceIndex >= PinValues.Num())
    {
        UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("Invalid pin or source index for GetExportTextForPin"));
        return TEXT("(RangeMin=0,RangeMax=0,Inclusive=true)");
    }
    
    // The format and order of this string is critical for proper UE property parsing
    // Get the struct values for this pin
    int32 RangeMin = PinValues[InPin->SourceIndex].RangeMin;
    int32 RangeMax = PinValues[InPin->SourceIndex].RangeMax;
    bool bInclusive = PinValues[InPin->SourceIndex].Inclusive;
    
    // Use property names matching UE's property naming convention (capitalized first letter)
    FString ExportText = FString::Printf(TEXT("(RangeMin=%d,RangeMax=%d,Inclusive=%s)"), 
                                     RangeMin,
                                     RangeMax,
                                     bInclusive ? TEXT("true") : TEXT("false"));
    
    UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("GetExportTextForPin: Pin=%s, Index=%d, Range=%s%d,%d%s, ExportText=%s"), 
        *InPin->PinName.ToString(), 
        InPin->SourceIndex,
        bInclusive ? TEXT("[") : TEXT("("),
        RangeMin, 
        RangeMax,
        bInclusive ? TEXT("]") : TEXT(")"),
        *ExportText);
    
    return ExportText;
}

void UK2Node_SwitchOnIntRanges::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
    bool bIsDirty = false;
    FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;

    if (PropertyName == TEXT("PinValues") || 
        PropertyName == TEXT("RangeMax") || 
        PropertyName == TEXT("RangeMin") || 
        PropertyName == TEXT("Inclusive"))
    {
        UE_LOG(LogSwitchOnIntRanges, Log, TEXT("Property changed: %s, reconstructing node"), *PropertyName.ToString());
        bIsDirty = true;
    }

    if (bIsDirty)
    {
        ReconstructNode();
    }
    
    Super::PostEditChangeProperty(PropertyChangedEvent);
    GetGraph()->NotifyNodeChanged(this);
}

void UK2Node_SwitchOnIntRanges::ValidateNodeDuringCompilation(FCompilerResultsLog& MessageLog) const
{
    Super::ValidateNodeDuringCompilation(MessageLog);

    // Check for invalid range configurations
    TArray<int32> InvalidRangePinIndex;
    TArray<int32> ReversedRangePinIndex;
    
    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {
        // Check for reversed ranges (min > max)
        if (PinValues[Index].RangeMin > PinValues[Index].RangeMax)
        {
            ReversedRangePinIndex.Add(Index);
            UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("Reversed range at pin %d: Min(%d) > Max(%d)"),
                Index, PinValues[Index].RangeMin, PinValues[Index].RangeMax);
        }
        
        TRange<int> Range = TRange<int>();
        Range = PinValues[Index].Inclusive ? 
            Range.Inclusive(PinValues[Index].RangeMin, PinValues[Index].RangeMax) : 
            Range.Exclusive(PinValues[Index].RangeMin, PinValues[Index].RangeMax);

        if (Range.IsEmpty())
        {
            InvalidRangePinIndex.Add(Index);
            UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("Empty range at pin %d: Min=%d, Max=%d, Inclusive=%s"),
                Index, PinValues[Index].RangeMin, PinValues[Index].RangeMax, 
                PinValues[Index].Inclusive ? TEXT("true") : TEXT("false"));
        }
    }

    // Check for overlapping ranges, which could lead to multiple execution paths
    // This isn't an error but could be confusing to users
    TArray<TPair<int32, int32>> OverlappingRanges;
    for (int32 i = 0; i < PinValues.Num(); ++i)
    {
        TRange<int> Range1 = PinValues[i].Inclusive ? 
            TRange<int>::Inclusive(PinValues[i].RangeMin, PinValues[i].RangeMax) : 
            TRange<int>::Exclusive(PinValues[i].RangeMin, PinValues[i].RangeMax);
            
        if (Range1.IsEmpty())
            continue;
            
        for (int32 j = i + 1; j < PinValues.Num(); ++j)
        {
            TRange<int> Range2 = PinValues[j].Inclusive ? 
                TRange<int>::Inclusive(PinValues[j].RangeMin, PinValues[j].RangeMax) : 
                TRange<int>::Exclusive(PinValues[j].RangeMin, PinValues[j].RangeMax);
                
            if (Range2.IsEmpty())
                continue;
                
            // Check for overlap
            TRange<int> Overlap = TRange<int>::Intersection(Range1, Range2);
            if (!Overlap.IsEmpty())
            {
                OverlappingRanges.Add(TPair<int32, int32>(i, j));
                UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("Overlapping ranges at pins %d and %d"), i, j);
            }
        }
    }

    // Report reversed ranges as errors
    if (ReversedRangePinIndex.Num() > 0)
    {
        FString WarningPins = TEXT("");
        for (int32 Index = 0; Index < ReversedRangePinIndex.Num(); ++Index)
        {
            WarningPins += FString::FromInt(ReversedRangePinIndex[Index]);
            if (Index < ReversedRangePinIndex.Num() - 1)
            {
                WarningPins += TEXT(", ");
            }
        }
        MessageLog.Error(*FText::Format(INVTEXT("@@ : Reversed range detected (Min > Max) in pin(s): {0}"), FText::FromString(WarningPins)).ToString(), this);
    }

    // Report empty ranges as warnings
    if (InvalidRangePinIndex.Num() > 0)
    {
        FString WarningPins = TEXT("");
        for (int32 Index = 0; Index < InvalidRangePinIndex.Num(); ++Index)
        {
            WarningPins += FString::FromInt(InvalidRangePinIndex[Index]);
            if (Index < InvalidRangePinIndex.Num() - 1)
            {
                WarningPins += TEXT(", ");
            }
        }
        MessageLog.Warning(*FText::Format(INVTEXT("@@ : Empty range detected in pin(s): {0}"), FText::FromString(WarningPins)).ToString(), this);
    }
    
    // Report overlapping ranges as warnings (multiple execution paths)
    if (OverlappingRanges.Num() > 0)
    {
        FString WarningMessage = TEXT("Overlapping ranges detected between pins:\n");
        for (int32 i = 0; i < OverlappingRanges.Num(); ++i)
        {
            int32 Pin1 = OverlappingRanges[i].Key;
            int32 Pin2 = OverlappingRanges[i].Value;
            
            WarningMessage += FString::Printf(TEXT("- Pin %d (%s) and Pin %d (%s)\n"), 
                Pin1, 
                *(PinValues[Pin1].Inclusive ? 
                    FString::Printf(TEXT("[%d,%d]"), PinValues[Pin1].RangeMin, PinValues[Pin1].RangeMax) : 
                    FString::Printf(TEXT("(%d,%d)"), PinValues[Pin1].RangeMin, PinValues[Pin1].RangeMax)),
                Pin2,
                *(PinValues[Pin2].Inclusive ? 
                    FString::Printf(TEXT("[%d,%d]"), PinValues[Pin2].RangeMin, PinValues[Pin2].RangeMax) : 
                    FString::Printf(TEXT("(%d,%d)"), PinValues[Pin2].RangeMin, PinValues[Pin2].RangeMax))
            );
        }
        WarningMessage += TEXT("Values in overlapping ranges will execute multiple paths.");
        MessageLog.Warning(*WarningMessage, this);
    }

    // ADD DEBUG INSPECTION FOR SELECTION PIN VALUE
    UEdGraphPin* SelectionPin = GetSelectionPin();
    if (SelectionPin && SelectionPin->LinkedTo.Num() > 0)
    {
        UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("VALIDATING - Selection pin has %d connections"), SelectionPin->LinkedTo.Num());
        
        // Log details about what's connected to the selection pin
        for (UEdGraphPin* LinkedPin : SelectionPin->LinkedTo)
        {
            UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("  - Connected to: %s, PinName=%s"), 
                *GetNameSafe(LinkedPin->GetOwningNode()), *LinkedPin->PinName.ToString());
            
            // If it's coming from a variable getter, show the variable name
            UK2Node_VariableGet* VarNode = Cast<UK2Node_VariableGet>(LinkedPin->GetOwningNode());
            if (VarNode)
            {
                FString VarName = VarNode->GetVarNameString();
                UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("    => Variable: %s"), *VarName);
            }
        }
    }
    else
    {
        UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("VALIDATING - Selection pin has no connections"));
        if (SelectionPin)
        {
            // Check if there's a default value set
            UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("  - Default value: %s"), *SelectionPin->DefaultValue);
        }
    }
}

void UK2Node_SwitchOnIntRanges::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
    UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("EXPANDING NODE - %s"), *GetName());
    
    UEdGraphPin* SelectionPin = GetSelectionPin();
    if (SelectionPin)
    {
        // Get the net that's feeding into the selection pin
        UEdGraphPin* SelectionNet = FEdGraphUtilities::GetNetFromPin(SelectionPin);
        
        if (SelectionNet)
        {
            UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("  - Selection pin connected to net: %s"), *SelectionNet->PinName.ToString());
            
            // Look at the selection pin's value during compilation
            FString PinValue = SelectionPin->DefaultValue;
            UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("  - Selection pin default value: %s"), *PinValue);
            
            // If pin is linked to something, trace where it's coming from
            if (SelectionPin->LinkedTo.Num() > 0)
            {
                UEdGraphPin* LinkedPin = SelectionPin->LinkedTo[0];
                UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("  - Linked from pin: %s on node %s"), 
                    *LinkedPin->PinName.ToString(), 
                    *GetNameSafe(LinkedPin->GetOwningNode()));
                
                // If it's a variable get node, print details
                UK2Node_VariableGet* VarNode = Cast<UK2Node_VariableGet>(LinkedPin->GetOwningNode());
                if (VarNode)
                {
                    FString VarName = VarNode->GetVarNameString();
                    UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("    => Variable: %s"), *VarName);
                    
                    // Get the blueprint that owns this node
                    if (UBlueprint* BP = CompilerContext.Blueprint)
                    {
                        UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("    => Blueprint: %s"), *BP->GetName());
                        
                        // Properly look up property using the schema
                        const UEdGraphSchema_K2* Schema = GetDefault<UEdGraphSchema_K2>();
                        bool bIsSparseProperty = false;
                        
                        if (BP->GeneratedClass)
                        {
                            FProperty* VarProperty = FKismetCompilerUtilities::FindPropertyInScope(
                                BP->GeneratedClass, 
                                LinkedPin,
                                CompilerContext.MessageLog, 
                                Schema,
                                BP->GeneratedClass,
                                bIsSparseProperty);
                                
                            if (VarProperty)
                            {
                                UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("    => Found variable property: %s"), *VarProperty->GetName());
                            }
                            else
                            {
                                UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("    => Could not find variable property"));
                            }
                        }
                    }
                }
            }
            else
            {
                UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("  - Selection pin has no incoming links"));
            }
        }
        else
        {
            UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("  - Selection pin not connected to any net"));
        }
        
        // Log all range values for debugging
        UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("Available range values:"));
        for (int32 i = 0; i < PinValues.Num(); ++i)
        {
            UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("  - Range %d: Min=%d, Max=%d, Inclusive=%s"), 
                i, 
                PinValues[i].RangeMin, 
                PinValues[i].RangeMax,
                PinValues[i].Inclusive ? TEXT("true") : TEXT("false"));
        }
    }
    
    // Call the parent implementation to do the actual expansion
    Super::ExpandNode(CompilerContext, SourceGraph);
}


