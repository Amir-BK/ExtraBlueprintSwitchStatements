// Copyright Amir Ben-Kiki 2025

#include "K2Node_SwitchOnIntRanges.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "EdGraph/EdGraphNode.h"
#include "KismetCompiler.h"
#include "EdGraphUtilities.h"
#include "Internationalization/Internationalization.h"
#include "UObject/Class.h"
#include "UObject/UnrealType.h"
#include "Logging/LogMacros.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "K2Node_VariableGet.h"
#include "Engine/Engine.h"
#include "ExtraSwitchComparatorsFunctionLibrary.h"

// Simple log category
DEFINE_LOG_CATEGORY_STATIC(LogSwitchOnIntRanges, Log, All);

UK2Node_SwitchOnIntRanges::UK2Node_SwitchOnIntRanges()
{
    // Set the function name and class to use the static function from ExtraSwitchComparatorsFunctionLibrary
    FunctionName = TEXT("IsIntNotWithinRange");
    FunctionClass = UExtraSwitchComparatorsFunctionLibrary::StaticClass();
    UE_LOG(LogSwitchOnIntRanges, Log, TEXT("SwitchOnIntRanges created"));
}

void UK2Node_SwitchOnIntRanges::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
    UClass* ActionKey = GetClass();
    if (ActionRegistrar.IsOpenForRegistration(ActionKey))
    {
        UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
        check(NodeSpawner);

        ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
    }
}

FText UK2Node_SwitchOnIntRanges::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
    return INVTEXT("Switch on Int Range");
}



inline FText UK2Node_SwitchOnIntRanges::GetTooltipText() const
{
    return INVTEXT("Switch statement using integer ranges, \nany execution path that matches the equality condition will execute \nif none do then default will execute");
}

void UK2Node_SwitchOnIntRanges::CreateSelectionPin()
{
    const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();
    UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Int, TEXT("Selection"));
    K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);

}

FName UK2Node_SwitchOnIntRanges::GetPinNameGivenIndex(int32 Index) const
{
    if (Index < 0 || Index >= PinNames.Num())
    {
        return NAME_None;
    }
    return PinNames[Index];
}

FEdGraphPinType UK2Node_SwitchOnIntRanges::GetInnerCaseType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
    PinType.PinSubCategoryObject = FSwitchIntRange::StaticStruct();
    return PinType;
}

FEdGraphPinType UK2Node_SwitchOnIntRanges::GetPinType() const
{
    FEdGraphPinType PinType;
    PinType.PinCategory = UEdGraphSchema_K2::PC_Int;
    return PinType;
}

void UK2Node_SwitchOnIntRanges::CreateCasePins()
{
    // Make sure we have a name for each pin value
    while (PinValues.Num() > PinNames.Num())
    {
        const FName PinName = GetUniquePinName();
        PinNames.Add(PinName);
    }

    // Trim excess names if we have more names than values
    if (PinNames.Num() > PinValues.Num())
    {
        PinNames.SetNum(PinValues.Num());
    }
    

    // Create a pin for each range
    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {
        UEdGraphPin* Pin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinNames[Index]);
        
        FString DisplayText;
        if (PinValues[Index].Inclusive)
        {
            DisplayText = FString::Printf(TEXT("[%d,%d]"), PinValues[Index].RangeMin, PinValues[Index].RangeMax);
        }
        else
        {
            DisplayText = FString::Printf(TEXT("(%d,%d)"), PinValues[Index].RangeMin, PinValues[Index].RangeMax);
        }
        
        Pin->PinFriendlyName = FText::FromString(DisplayText);
        Pin->SourceIndex = Index;

    }
}

FName UK2Node_SwitchOnIntRanges::GetUniquePinName()
{
    FName NewPinName;
    int32 Index = 0;
    while (true)
    {
        NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
        if (!FindPin(NewPinName))
        {
            break;
        }
    }
    return NewPinName;
}

FString UK2Node_SwitchOnIntRanges::GetExportTextForPin(const UEdGraphPin* InPin) const
{
    if (!InPin || InPin->SourceIndex < 0 || InPin->SourceIndex >= PinValues.Num())
    {
        return TEXT("(RangeMin=0,RangeMax=0,Inclusive=true)");
    }
    
    // The format and order of this string is critical for proper UE property parsing
    // Get the struct values for this pin
    int32 RangeMin = PinValues[InPin->SourceIndex].RangeMin;
    int32 RangeMax = PinValues[InPin->SourceIndex].RangeMax;
    bool bInclusive = PinValues[InPin->SourceIndex].Inclusive;
    
    // Use property names matching UE's property naming convention (capitalized first letter)
    FString ExportText = FString::Printf(TEXT("(RangeMin=%d,RangeMax=%d,Inclusive=%s)"), 
                                     RangeMin,
                                     RangeMax,
                                     bInclusive ? TEXT("true") : TEXT("false"));
    
    
    return ExportText;
}

void UK2Node_SwitchOnIntRanges::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
    bool bIsDirty = false;
    FName PropertyName = (PropertyChangedEvent.Property != NULL) ? PropertyChangedEvent.Property->GetFName() : NAME_None;

    if (PropertyName == TEXT("PinValues") || 
        PropertyName == TEXT("RangeMax") || 
        PropertyName == TEXT("RangeMin") || 
        PropertyName == TEXT("Inclusive"))
    {
        UE_LOG(LogSwitchOnIntRanges, Log, TEXT("Property changed: %s, reconstructing node"), *PropertyName.ToString());
        bIsDirty = true;
    }

    if (bIsDirty)
    {
        ReconstructNode();
    }
    
    Super::PostEditChangeProperty(PropertyChangedEvent);
    GetGraph()->NotifyNodeChanged(this);
}

void UK2Node_SwitchOnIntRanges::ValidateNodeDuringCompilation(FCompilerResultsLog& MessageLog) const
{
    Super::ValidateNodeDuringCompilation(MessageLog);

    // Check for invalid range configurations
    TArray<int32> InvalidRangePinIndex;
    TArray<int32> ReversedRangePinIndex;
    
    for (int32 Index = 0; Index < PinValues.Num(); ++Index)
    {
        // Check for reversed ranges (min > max)
        if (PinValues[Index].RangeMin > PinValues[Index].RangeMax)
        {
            ReversedRangePinIndex.Add(Index);
            UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("Reversed range at pin %d: Min(%d) > Max(%d)"),
                Index, PinValues[Index].RangeMin, PinValues[Index].RangeMax);
        }
        
        TRange<int> Range = TRange<int>();
        Range = PinValues[Index].Inclusive ? 
            Range.Inclusive(PinValues[Index].RangeMin, PinValues[Index].RangeMax) : 
            Range.Exclusive(PinValues[Index].RangeMin, PinValues[Index].RangeMax);

        if (Range.IsEmpty())
        {
            InvalidRangePinIndex.Add(Index);
            UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("Empty range at pin %d: Min=%d, Max=%d, Inclusive=%s"),
                Index, PinValues[Index].RangeMin, PinValues[Index].RangeMax, 
                PinValues[Index].Inclusive ? TEXT("true") : TEXT("false"));
        }
    }

    // Check for overlapping ranges, which could lead to multiple execution paths
    // This isn't an error but could be confusing to users
    TArray<TPair<int32, int32>> OverlappingRanges;
    for (int32 i = 0; i < PinValues.Num(); ++i)
    {
        TRange<int> Range1 = PinValues[i].Inclusive ? 
            TRange<int>::Inclusive(PinValues[i].RangeMin, PinValues[i].RangeMax) : 
            TRange<int>::Exclusive(PinValues[i].RangeMin, PinValues[i].RangeMax);
            
        if (Range1.IsEmpty())
            continue;
            
        for (int32 j = i + 1; j < PinValues.Num(); ++j)
        {
            TRange<int> Range2 = PinValues[j].Inclusive ? 
                TRange<int>::Inclusive(PinValues[j].RangeMin, PinValues[j].RangeMax) : 
                TRange<int>::Exclusive(PinValues[j].RangeMin, PinValues[j].RangeMax);
                
            if (Range2.IsEmpty())
                continue;
                
            // Check for overlap
            TRange<int> Overlap = TRange<int>::Intersection(Range1, Range2);
            if (!Overlap.IsEmpty())
            {
                OverlappingRanges.Add(TPair<int32, int32>(i, j));
                UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("Overlapping ranges at pins %d and %d"), i, j);
            }
        }
    }

    // Report reversed ranges as errors
    if (ReversedRangePinIndex.Num() > 0)
    {
        FString WarningPins = TEXT("");
        for (int32 Index = 0; Index < ReversedRangePinIndex.Num(); ++Index)
        {
            WarningPins += FString::FromInt(ReversedRangePinIndex[Index]);
            if (Index < ReversedRangePinIndex.Num() - 1)
            {
                WarningPins += TEXT(", ");
            }
        }
        MessageLog.Error(*FText::Format(INVTEXT("@@ : Reversed range detected (Min > Max) in pin(s): {0}"), FText::FromString(WarningPins)).ToString(), this);
    }

    // Report empty ranges as warnings
    if (InvalidRangePinIndex.Num() > 0)
    {
        FString WarningPins = TEXT("");
        for (int32 Index = 0; Index < InvalidRangePinIndex.Num(); ++Index)
        {
            WarningPins += FString::FromInt(InvalidRangePinIndex[Index]);
            if (Index < InvalidRangePinIndex.Num() - 1)
            {
                WarningPins += TEXT(", ");
            }
        }
        MessageLog.Warning(*FText::Format(INVTEXT("@@ : Empty range detected in pin(s): {0}"), FText::FromString(WarningPins)).ToString(), this);
    }
    
    // Report overlapping ranges as warnings (multiple execution paths)
    if (OverlappingRanges.Num() > 0)
    {
        FString WarningMessage = TEXT("Overlapping ranges detected between pins:\n");
        for (int32 i = 0; i < OverlappingRanges.Num(); ++i)
        {
            int32 Pin1 = OverlappingRanges[i].Key;
            int32 Pin2 = OverlappingRanges[i].Value;
            
            WarningMessage += FString::Printf(TEXT("- Pin %d (%s) and Pin %d (%s)\n"), 
                Pin1, 
                *(PinValues[Pin1].Inclusive ? 
                    FString::Printf(TEXT("[%d,%d]"), PinValues[Pin1].RangeMin, PinValues[Pin1].RangeMax) : 
                    FString::Printf(TEXT("(%d,%d)"), PinValues[Pin1].RangeMin, PinValues[Pin1].RangeMax)),
                Pin2,
                *(PinValues[Pin2].Inclusive ? 
                    FString::Printf(TEXT("[%d,%d]"), PinValues[Pin2].RangeMin, PinValues[Pin2].RangeMax) : 
                    FString::Printf(TEXT("(%d,%d)"), PinValues[Pin2].RangeMin, PinValues[Pin2].RangeMax))
            );
        }
        WarningMessage += TEXT("Values in overlapping ranges will execute multiple paths.");
        MessageLog.Warning(*WarningMessage, this);
    }

    // ADD DEBUG INSPECTION FOR SELECTION PIN VALUE
    UEdGraphPin* SelectionPin = GetSelectionPin();
    if (SelectionPin && SelectionPin->LinkedTo.Num() > 0)
    {
        UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("VALIDATING - Selection pin has %d connections"), SelectionPin->LinkedTo.Num());
        
        // Log details about what's connected to the selection pin
        for (UEdGraphPin* LinkedPin : SelectionPin->LinkedTo)
        {
            UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("  - Connected to: %s, PinName=%s"), 
                *GetNameSafe(LinkedPin->GetOwningNode()), *LinkedPin->PinName.ToString());
            
            // If it's coming from a variable getter, show the variable name
            UK2Node_VariableGet* VarNode = Cast<UK2Node_VariableGet>(LinkedPin->GetOwningNode());
            if (VarNode)
            {
                FString VarName = VarNode->GetVarNameString();
                UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("    => Variable: %s"), *VarName);
            }
        }
    }
    else
    {
        UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("VALIDATING - Selection pin has no connections"));
        if (SelectionPin)
        {
            // Check if there's a default value set
            UE_LOG(LogSwitchOnIntRanges, Warning, TEXT("  - Default value: %s"), *SelectionPin->DefaultValue);
        }
    }
}
